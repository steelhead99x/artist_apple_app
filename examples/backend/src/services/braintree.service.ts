// @ts-ignore - braintree types not available
import braintree from 'braintree';

// Initialize Braintree gateway (supports Venmo)
const gateway = process.env.BRAINTREE_MERCHANT_ID && 
                process.env.BRAINTREE_PUBLIC_KEY && 
                process.env.BRAINTREE_PRIVATE_KEY
  ? new braintree.BraintreeGateway({
      environment: process.env.NODE_ENV === 'production' 
        ? braintree.Environment.Production 
        : braintree.Environment.Sandbox,
      merchantId: process.env.BRAINTREE_MERCHANT_ID,
      publicKey: process.env.BRAINTREE_PUBLIC_KEY,
      privateKey: process.env.BRAINTREE_PRIVATE_KEY,
    })
  : null;

export interface BraintreeTransaction {
  id: string;
  status: string;
  amount: number;
  paymentMethod: string;
}

export interface CreateTransactionParams {
  amount: number;
  paymentMethodNonce: string; // Generated by Braintree client SDK
  deviceData?: string; // For fraud protection
  description?: string;
}

/**
 * Generate a client token for Braintree Drop-in UI
 */
export async function generateClientToken(customerId?: string): Promise<string> {
  if (!gateway) {
    throw new Error('Braintree is not configured. Please set BRAINTREE_* environment variables.');
  }

  try {
    const response = await gateway.clientToken.generate({
      customerId: customerId, // Optional: for returning customers
    });

    return response.clientToken;
  } catch (error: any) {
    console.error('Braintree generate token error:', error);
    throw new Error(`Failed to generate Braintree client token: ${error.message}`);
  }
}

/**
 * Process a Venmo/Braintree transaction
 */
export async function createTransaction(params: CreateTransactionParams): Promise<BraintreeTransaction> {
  if (!gateway) {
    throw new Error('Braintree is not configured');
  }

  try {
    const result = await gateway.transaction.sale({
      amount: params.amount.toFixed(2),
      paymentMethodNonce: params.paymentMethodNonce,
      deviceData: params.deviceData,
      options: {
        submitForSettlement: true, // Automatically submit for settlement
      },
    });

    if (!result.success) {
      const errorMessage = result.message || 'Transaction failed';
      console.error('Braintree transaction error:', result);
      throw new Error(errorMessage);
    }

    const transaction = result.transaction;
    if (!transaction) {
      throw new Error('Transaction result is empty');
    }

    // Determine payment method used (Venmo, PayPal, Credit Card, etc.)
    let paymentMethod = 'unknown';
    if (transaction.venmoAccount) {
      paymentMethod = 'venmo';
    } else if (transaction.paypalAccount) {
      paymentMethod = 'paypal';
    } else if (transaction.creditCard) {
      paymentMethod = 'credit_card';
    }

    return {
      id: transaction.id,
      status: transaction.status,
      amount: parseFloat(transaction.amount),
      paymentMethod,
    };
  } catch (error: any) {
    console.error('Braintree transaction error:', error);
    throw new Error(`Braintree transaction failed: ${error.message}`);
  }
}

/**
 * Verify a transaction was successful
 */
export async function verifyTransaction(transactionId: string): Promise<boolean> {
  if (!gateway) {
    throw new Error('Braintree is not configured');
  }

  try {
    const transaction = await gateway.transaction.find(transactionId);
    return transaction.status === 'settled' || transaction.status === 'settling';
  } catch (error: any) {
    console.error('Braintree verify transaction error:', error);
    return false;
  }
}

/**
 * Get transaction details
 */
export async function getTransaction(transactionId: string) {
  if (!gateway) {
    throw new Error('Braintree is not configured');
  }

  return await gateway.transaction.find(transactionId);
}

/**
 * Refund a transaction
 */
export async function refundTransaction(transactionId: string, amount?: string) {
  if (!gateway) {
    throw new Error('Braintree is not configured');
  }

  return await gateway.transaction.refund(transactionId, amount);
}

export default {
  generateClientToken,
  createTransaction,
  verifyTransaction,
  getTransaction,
  refundTransaction,
};

